// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query_identity.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	identity_entity "github.com/shandysiswandi/gobite/internal/identity/entity"
	vo "github.com/shandysiswandi/gobite/internal/pkg/valueobject"
)

const countIdentityUserFilter = `-- name: CountIdentityUserFilter :one
SELECT COUNT(id)
FROM identity_users
WHERE
    (NOT $1::boolean OR status = ANY($2::smallint[]))
    AND (
      NOT $3::boolean
      OR email ILIKE '%' || $4::varchar || '%'
      OR full_name ILIKE '%' || $4::varchar || '%'
    )
    AND (NOT $5::boolean OR created_at >= $6::timestamptz)
    AND (NOT $7::boolean OR created_at <= $8::timestamptz)
    AND deleted_at IS NULL
`

type CountIdentityUserFilterParams struct {
	FilterByStatus   bool
	Statuses         []int16
	FilterBySearch   bool
	Search           string
	FilterByDateFrom bool
	DateFrom         pgtype.Timestamptz
	FilterByDateTo   bool
	DateTo           pgtype.Timestamptz
}

func (q *Queries) CountIdentityUserFilter(ctx context.Context, arg CountIdentityUserFilterParams) (int64, error) {
	row := q.db.QueryRow(ctx, countIdentityUserFilter,
		arg.FilterByStatus,
		arg.Statuses,
		arg.FilterBySearch,
		arg.Search,
		arg.FilterByDateFrom,
		arg.DateFrom,
		arg.FilterByDateTo,
		arg.DateTo,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createIdentityChallenge = `-- name: CreateIdentityChallenge :exec
INSERT INTO identity_challenges (id, user_id, token, purpose, expires_at, metadata) 
VALUES ($1, $2, $3, $4, $5, $6)
`

type CreateIdentityChallengeParams struct {
	ID        int64
	UserID    int64
	Token     string
	Purpose   identity_entity.ChallengePurpose
	ExpiresAt pgtype.Timestamptz
	Metadata  vo.JSONMap
}

func (q *Queries) CreateIdentityChallenge(ctx context.Context, arg CreateIdentityChallengeParams) error {
	_, err := q.db.Exec(ctx, createIdentityChallenge,
		arg.ID,
		arg.UserID,
		arg.Token,
		arg.Purpose,
		arg.ExpiresAt,
		arg.Metadata,
	)
	return err
}

type CreateIdentityMFABackupCodesParams struct {
	ID     int64
	UserID int64
	Code   string
}

const createIdentityMFAFactor = `-- name: CreateIdentityMFAFactor :exec
INSERT INTO identity_mfa_factors (id, user_id, type, friendly_name, secret, key_version, is_verified)
VALUES ($1, $2, $3, $4, $5, $6, $7)
`

type CreateIdentityMFAFactorParams struct {
	ID           int64
	UserID       int64
	Type         identity_entity.MFAType
	FriendlyName string
	Secret       []byte
	KeyVersion   int16
	IsVerified   bool
}

func (q *Queries) CreateIdentityMFAFactor(ctx context.Context, arg CreateIdentityMFAFactorParams) error {
	_, err := q.db.Exec(ctx, createIdentityMFAFactor,
		arg.ID,
		arg.UserID,
		arg.Type,
		arg.FriendlyName,
		arg.Secret,
		arg.KeyVersion,
		arg.IsVerified,
	)
	return err
}

const createIdentityRefreshToken = `-- name: CreateIdentityRefreshToken :exec

INSERT INTO identity_refresh_tokens (id, user_id, token, expires_at, metadata) 
VALUES ($1, $2, $3, $4, $5)
`

type CreateIdentityRefreshTokenParams struct {
	ID        int64
	UserID    int64
	Token     string
	ExpiresAt pgtype.Timestamptz
	Metadata  vo.JSONMap
}

// ***** ***** *****
// CREATE DATA
// ***** ***** *****
func (q *Queries) CreateIdentityRefreshToken(ctx context.Context, arg CreateIdentityRefreshTokenParams) error {
	_, err := q.db.Exec(ctx, createIdentityRefreshToken,
		arg.ID,
		arg.UserID,
		arg.Token,
		arg.ExpiresAt,
		arg.Metadata,
	)
	return err
}

const createIdentityUser = `-- name: CreateIdentityUser :exec
INSERT INTO identity_users (id, email, full_name, avatar_url, status, created_by, updated_by)
VALUES ($1, $2, $3, $4, $5, $6, $7)
`

type CreateIdentityUserParams struct {
	ID        int64
	Email     string
	FullName  string
	AvatarUrl string
	Status    identity_entity.UserStatus
	CreatedBy int64
	UpdatedBy int64
}

func (q *Queries) CreateIdentityUser(ctx context.Context, arg CreateIdentityUserParams) error {
	_, err := q.db.Exec(ctx, createIdentityUser,
		arg.ID,
		arg.Email,
		arg.FullName,
		arg.AvatarUrl,
		arg.Status,
		arg.CreatedBy,
		arg.UpdatedBy,
	)
	return err
}

const createIdentityUserCredential = `-- name: CreateIdentityUserCredential :exec
INSERT INTO identity_user_credentials (user_id, password)
VALUES ($1, $2)
`

type CreateIdentityUserCredentialParams struct {
	UserID   int64
	Password string
}

func (q *Queries) CreateIdentityUserCredential(ctx context.Context, arg CreateIdentityUserCredentialParams) error {
	_, err := q.db.Exec(ctx, createIdentityUserCredential, arg.UserID, arg.Password)
	return err
}

const deleteIdentityChallengeByID = `-- name: DeleteIdentityChallengeByID :exec

DELETE FROM identity_challenges WHERE id = $1
`

// ***** ***** *****
// DELETE DATA
// ***** ***** *****
func (q *Queries) DeleteIdentityChallengeByID(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteIdentityChallengeByID, id)
	return err
}

const deleteIdentityMFABackupCodeByUserID = `-- name: DeleteIdentityMFABackupCodeByUserID :exec
DELETE FROM identity_mfa_backup_codes WHERE user_id = $1
`

func (q *Queries) DeleteIdentityMFABackupCodeByUserID(ctx context.Context, userID int64) error {
	_, err := q.db.Exec(ctx, deleteIdentityMFABackupCodeByUserID, userID)
	return err
}

const getIdentityChallengeUserByTokenPurpose = `-- name: GetIdentityChallengeUserByTokenPurpose :one
SELECT u.id AS user_id, u.status, u.email, c.id, c.token, c.purpose, c.metadata
FROM identity_challenges c
JOIN identity_users AS u ON u.id = c.user_id
WHERE 
    u.deleted_at IS NULL
    AND c.token = $1 
    AND c.purpose = $2 
    AND c.expires_at > NOW()
`

type GetIdentityChallengeUserByTokenPurposeParams struct {
	Token   string
	Purpose identity_entity.ChallengePurpose
}

type GetIdentityChallengeUserByTokenPurposeRow struct {
	UserID   int64
	Status   identity_entity.UserStatus
	Email    string
	ID       int64
	Token    string
	Purpose  identity_entity.ChallengePurpose
	Metadata vo.JSONMap
}

func (q *Queries) GetIdentityChallengeUserByTokenPurpose(ctx context.Context, arg GetIdentityChallengeUserByTokenPurposeParams) (GetIdentityChallengeUserByTokenPurposeRow, error) {
	row := q.db.QueryRow(ctx, getIdentityChallengeUserByTokenPurpose, arg.Token, arg.Purpose)
	var i GetIdentityChallengeUserByTokenPurposeRow
	err := row.Scan(
		&i.UserID,
		&i.Status,
		&i.Email,
		&i.ID,
		&i.Token,
		&i.Purpose,
		&i.Metadata,
	)
	return i, err
}

const getIdentityMFABackupCodeByUserID = `-- name: GetIdentityMFABackupCodeByUserID :many
SELECT id, user_id, code, used_at 
FROM identity_mfa_backup_codes 
WHERE 
    user_id = $1
    AND used_at IS NULL
`

type GetIdentityMFABackupCodeByUserIDRow struct {
	ID     int64
	UserID int64
	Code   string
	UsedAt pgtype.Timestamptz
}

func (q *Queries) GetIdentityMFABackupCodeByUserID(ctx context.Context, userID int64) ([]GetIdentityMFABackupCodeByUserIDRow, error) {
	rows, err := q.db.Query(ctx, getIdentityMFABackupCodeByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetIdentityMFABackupCodeByUserIDRow
	for rows.Next() {
		var i GetIdentityMFABackupCodeByUserIDRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Code,
			&i.UsedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getIdentityMFAFactorByID = `-- name: GetIdentityMFAFactorByID :one
SELECT id, user_id, type, friendly_name, secret, key_version, is_verified, last_used_at 
FROM identity_mfa_factors 
WHERE 
    id = $1 AND 
    user_id = $2
`

type GetIdentityMFAFactorByIDParams struct {
	ID     int64
	UserID int64
}

type GetIdentityMFAFactorByIDRow struct {
	ID           int64
	UserID       int64
	Type         identity_entity.MFAType
	FriendlyName string
	Secret       []byte
	KeyVersion   int16
	IsVerified   bool
	LastUsedAt   pgtype.Timestamptz
}

func (q *Queries) GetIdentityMFAFactorByID(ctx context.Context, arg GetIdentityMFAFactorByIDParams) (GetIdentityMFAFactorByIDRow, error) {
	row := q.db.QueryRow(ctx, getIdentityMFAFactorByID, arg.ID, arg.UserID)
	var i GetIdentityMFAFactorByIDRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Type,
		&i.FriendlyName,
		&i.Secret,
		&i.KeyVersion,
		&i.IsVerified,
		&i.LastUsedAt,
	)
	return i, err
}

const getIdentityMFAFactorByUserID = `-- name: GetIdentityMFAFactorByUserID :many
SELECT id, user_id, type, friendly_name, secret, key_version, is_verified, last_used_at 
FROM identity_mfa_factors 
WHERE 
    user_id = $1 AND 
    is_verified = $2
ORDER BY created_at ASC
`

type GetIdentityMFAFactorByUserIDParams struct {
	UserID     int64
	IsVerified bool
}

type GetIdentityMFAFactorByUserIDRow struct {
	ID           int64
	UserID       int64
	Type         identity_entity.MFAType
	FriendlyName string
	Secret       []byte
	KeyVersion   int16
	IsVerified   bool
	LastUsedAt   pgtype.Timestamptz
}

func (q *Queries) GetIdentityMFAFactorByUserID(ctx context.Context, arg GetIdentityMFAFactorByUserIDParams) ([]GetIdentityMFAFactorByUserIDRow, error) {
	rows, err := q.db.Query(ctx, getIdentityMFAFactorByUserID, arg.UserID, arg.IsVerified)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetIdentityMFAFactorByUserIDRow
	for rows.Next() {
		var i GetIdentityMFAFactorByUserIDRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Type,
			&i.FriendlyName,
			&i.Secret,
			&i.KeyVersion,
			&i.IsVerified,
			&i.LastUsedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getIdentityUserByEmail = `-- name: GetIdentityUserByEmail :one
SELECT id, email, full_name, avatar_url, status 
FROM identity_users 
WHERE 
    lower(email) = lower($1)
    AND deleted_at IS NULL
`

type GetIdentityUserByEmailRow struct {
	ID        int64
	Email     string
	FullName  string
	AvatarUrl string
	Status    identity_entity.UserStatus
}

func (q *Queries) GetIdentityUserByEmail(ctx context.Context, email string) (GetIdentityUserByEmailRow, error) {
	row := q.db.QueryRow(ctx, getIdentityUserByEmail, email)
	var i GetIdentityUserByEmailRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.FullName,
		&i.AvatarUrl,
		&i.Status,
	)
	return i, err
}

const getIdentityUserByEmailIncludeDeleted = `-- name: GetIdentityUserByEmailIncludeDeleted :one
SELECT id, email, full_name, avatar_url, status 
FROM identity_users
WHERE 
    lower(email) = lower($1)
`

type GetIdentityUserByEmailIncludeDeletedRow struct {
	ID        int64
	Email     string
	FullName  string
	AvatarUrl string
	Status    identity_entity.UserStatus
}

func (q *Queries) GetIdentityUserByEmailIncludeDeleted(ctx context.Context, email string) (GetIdentityUserByEmailIncludeDeletedRow, error) {
	row := q.db.QueryRow(ctx, getIdentityUserByEmailIncludeDeleted, email)
	var i GetIdentityUserByEmailIncludeDeletedRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.FullName,
		&i.AvatarUrl,
		&i.Status,
	)
	return i, err
}

const getIdentityUserByEmailsIncludeDeleted = `-- name: GetIdentityUserByEmailsIncludeDeleted :many
SELECT id, email, full_name, avatar_url, status  
FROM identity_users
WHERE 
    email ILIKE ANY($1::varchar[])
`

type GetIdentityUserByEmailsIncludeDeletedRow struct {
	ID        int64
	Email     string
	FullName  string
	AvatarUrl string
	Status    identity_entity.UserStatus
}

func (q *Queries) GetIdentityUserByEmailsIncludeDeleted(ctx context.Context, emails []string) ([]GetIdentityUserByEmailsIncludeDeletedRow, error) {
	rows, err := q.db.Query(ctx, getIdentityUserByEmailsIncludeDeleted, emails)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetIdentityUserByEmailsIncludeDeletedRow
	for rows.Next() {
		var i GetIdentityUserByEmailsIncludeDeletedRow
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.FullName,
			&i.AvatarUrl,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getIdentityUserByID = `-- name: GetIdentityUserByID :one
SELECT id, email, full_name, avatar_url, status, updated_at, deleted_at  
FROM identity_users 
WHERE
    id = $1
    AND deleted_at IS NULL
`

type GetIdentityUserByIDRow struct {
	ID        int64
	Email     string
	FullName  string
	AvatarUrl string
	Status    identity_entity.UserStatus
	UpdatedAt pgtype.Timestamptz
	DeletedAt pgtype.Timestamptz
}

func (q *Queries) GetIdentityUserByID(ctx context.Context, id int64) (GetIdentityUserByIDRow, error) {
	row := q.db.QueryRow(ctx, getIdentityUserByID, id)
	var i GetIdentityUserByIDRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.FullName,
		&i.AvatarUrl,
		&i.Status,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getIdentityUserByIDIncludeDeleted = `-- name: GetIdentityUserByIDIncludeDeleted :one
SELECT id, email, full_name, avatar_url, status, updated_at, deleted_at
FROM identity_users 
WHERE
    id = $1
`

type GetIdentityUserByIDIncludeDeletedRow struct {
	ID        int64
	Email     string
	FullName  string
	AvatarUrl string
	Status    identity_entity.UserStatus
	UpdatedAt pgtype.Timestamptz
	DeletedAt pgtype.Timestamptz
}

func (q *Queries) GetIdentityUserByIDIncludeDeleted(ctx context.Context, id int64) (GetIdentityUserByIDIncludeDeletedRow, error) {
	row := q.db.QueryRow(ctx, getIdentityUserByIDIncludeDeleted, id)
	var i GetIdentityUserByIDIncludeDeletedRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.FullName,
		&i.AvatarUrl,
		&i.Status,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getIdentityUserCredentialInfo = `-- name: GetIdentityUserCredentialInfo :one
SELECT u.id, u.email, u.status, c.password
FROM identity_users AS u
JOIN identity_user_credentials AS c ON u.id = c.user_id
WHERE
    u.id = $1
    AND u.deleted_at IS NULL
`

type GetIdentityUserCredentialInfoRow struct {
	ID       int64
	Email    string
	Status   identity_entity.UserStatus
	Password string
}

func (q *Queries) GetIdentityUserCredentialInfo(ctx context.Context, id int64) (GetIdentityUserCredentialInfoRow, error) {
	row := q.db.QueryRow(ctx, getIdentityUserCredentialInfo, id)
	var i GetIdentityUserCredentialInfoRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Status,
		&i.Password,
	)
	return i, err
}

const getIdentityUserFilter = `-- name: GetIdentityUserFilter :many
SELECT id, email, full_name, avatar_url, status, updated_at
FROM identity_users
WHERE
    (NOT $1::boolean OR status = ANY($2::smallint[]))
    AND (
      NOT $3::boolean
      OR email ILIKE '%' || $4::varchar || '%'
      OR full_name ILIKE '%' || $4::varchar || '%'
    )
    AND (NOT $5::boolean OR created_at >= $6::timestamptz)
    AND (NOT $7::boolean OR created_at <= $8::timestamptz)
    AND deleted_at IS NULL
ORDER BY
  -- email
  CASE WHEN $9::varchar = 'email:asc'  THEN email END ASC,
  CASE WHEN $9::varchar = 'email:desc' THEN email END DESC,
  -- full_name
  CASE WHEN $9::varchar = 'full_name:asc'  THEN full_name END ASC,
  CASE WHEN $9::varchar = 'full_name:desc' THEN full_name END DESC,
  -- updated_at
  CASE WHEN $9::varchar = 'updated_at:asc'  THEN updated_at END ASC,
  CASE WHEN $9::varchar = 'updated_at:desc' THEN updated_at END DESC,
  -- status
  CASE WHEN $9::varchar = 'status:asc'  THEN status END ASC,
  CASE WHEN $9::varchar = 'status:desc' THEN status END DESC,
  -- fallback
  created_at DESC, id DESC
LIMIT $11 OFFSET $10
`

type GetIdentityUserFilterParams struct {
	FilterByStatus   bool
	Statuses         []int16
	FilterBySearch   bool
	Search           string
	FilterByDateFrom bool
	DateFrom         pgtype.Timestamptz
	FilterByDateTo   bool
	DateTo           pgtype.Timestamptz
	OrderBy          string
	PageOffset       int32
	PageLimit        int32
}

type GetIdentityUserFilterRow struct {
	ID        int64
	Email     string
	FullName  string
	AvatarUrl string
	Status    identity_entity.UserStatus
	UpdatedAt pgtype.Timestamptz
}

func (q *Queries) GetIdentityUserFilter(ctx context.Context, arg GetIdentityUserFilterParams) ([]GetIdentityUserFilterRow, error) {
	rows, err := q.db.Query(ctx, getIdentityUserFilter,
		arg.FilterByStatus,
		arg.Statuses,
		arg.FilterBySearch,
		arg.Search,
		arg.FilterByDateFrom,
		arg.DateFrom,
		arg.FilterByDateTo,
		arg.DateTo,
		arg.OrderBy,
		arg.PageOffset,
		arg.PageLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetIdentityUserFilterRow
	for rows.Next() {
		var i GetIdentityUserFilterRow
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.FullName,
			&i.AvatarUrl,
			&i.Status,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getIdentityUserLoginInfo = `-- name: GetIdentityUserLoginInfo :one

SELECT u.id, u.email, u.status, c.password, EXISTS (SELECT 1 FROM identity_mfa_factors m WHERE m.user_id = u.id AND m.is_verified = TRUE) AS has_mfa
FROM identity_users AS u
JOIN identity_user_credentials AS c ON u.id = c.user_id
WHERE 
    lower(u.email) = lower($1) 
    AND u.deleted_at IS NULL
`

type GetIdentityUserLoginInfoRow struct {
	ID       int64
	Email    string
	Status   identity_entity.UserStatus
	Password string
	HasMfa   bool
}

// ***** ***** *****
// SELECT DATA
// ***** ***** *****
func (q *Queries) GetIdentityUserLoginInfo(ctx context.Context, email string) (GetIdentityUserLoginInfoRow, error) {
	row := q.db.QueryRow(ctx, getIdentityUserLoginInfo, email)
	var i GetIdentityUserLoginInfoRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Status,
		&i.Password,
		&i.HasMfa,
	)
	return i, err
}

const getIdentityUserRefreshToken = `-- name: GetIdentityUserRefreshToken :one
SELECT rt.id, rt.user_id, rt.token, rt.expires_at, rt.revoked, rt.replaced_by_token_id, u.email, u.status AS user_status
FROM identity_refresh_tokens rt
JOIN identity_users u ON u.id = rt.user_id
WHERE 
    rt.token = $1
    AND u.deleted_at IS NULL
`

type GetIdentityUserRefreshTokenRow struct {
	ID                int64
	UserID            int64
	Token             string
	ExpiresAt         pgtype.Timestamptz
	Revoked           bool
	ReplacedByTokenID pgtype.Int8
	Email             string
	UserStatus        identity_entity.UserStatus
}

func (q *Queries) GetIdentityUserRefreshToken(ctx context.Context, token string) (GetIdentityUserRefreshTokenRow, error) {
	row := q.db.QueryRow(ctx, getIdentityUserRefreshToken, token)
	var i GetIdentityUserRefreshTokenRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Token,
		&i.ExpiresAt,
		&i.Revoked,
		&i.ReplacedByTokenID,
		&i.Email,
		&i.UserStatus,
	)
	return i, err
}

const markIdentityMFABackupCodeUsed = `-- name: MarkIdentityMFABackupCodeUsed :execrows
UPDATE identity_mfa_backup_codes
SET 
    used_at = NOW()
WHERE 
    user_id = $1 
    AND id = $2 
    AND used_at IS NULL
`

type MarkIdentityMFABackupCodeUsedParams struct {
	UserID int64
	ID     int64
}

func (q *Queries) MarkIdentityMFABackupCodeUsed(ctx context.Context, arg MarkIdentityMFABackupCodeUsedParams) (int64, error) {
	result, err := q.db.Exec(ctx, markIdentityMFABackupCodeUsed, arg.UserID, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const markIdentityUserDeleted = `-- name: MarkIdentityUserDeleted :exec
UPDATE identity_users
SET 
    deleted_at = NOW(), 
    deleted_by = $1
WHERE
    id = $2 AND
    deleted_at IS NULL
`

type MarkIdentityUserDeletedParams struct {
	DeletedBy pgtype.Int8
	ID        int64
}

func (q *Queries) MarkIdentityUserDeleted(ctx context.Context, arg MarkIdentityUserDeletedParams) error {
	_, err := q.db.Exec(ctx, markIdentityUserDeleted, arg.DeletedBy, arg.ID)
	return err
}

const patcIdentityUser = `-- name: PatcIdentityUser :exec
UPDATE identity_users
SET 
    email = COALESCE($1, email),
    full_name = COALESCE($2, full_name),
    avatar_url = COALESCE($3, avatar_url),
    status = COALESCE($4::smallint, status),
    updated_by = COALESCE($5, updated_by)
WHERE 
    id = $6
`

type PatcIdentityUserParams struct {
	Email     pgtype.Text
	FullName  pgtype.Text
	AvatarUrl pgtype.Text
	Status    pgtype.Int2
	UpdatedBy pgtype.Int8
	ID        int64
}

func (q *Queries) PatcIdentityUser(ctx context.Context, arg PatcIdentityUserParams) error {
	_, err := q.db.Exec(ctx, patcIdentityUser,
		arg.Email,
		arg.FullName,
		arg.AvatarUrl,
		arg.Status,
		arg.UpdatedBy,
		arg.ID,
	)
	return err
}

const replaceIdentityRefreshToken = `-- name: ReplaceIdentityRefreshToken :execrows
UPDATE identity_refresh_tokens 
SET 
    revoked = TRUE, 
    replaced_by_token_id = $1::BIGINT
WHERE 
    id = $2
`

type ReplaceIdentityRefreshTokenParams struct {
	NewTokenID int64
	OldTokenID int64
}

func (q *Queries) ReplaceIdentityRefreshToken(ctx context.Context, arg ReplaceIdentityRefreshTokenParams) (int64, error) {
	result, err := q.db.Exec(ctx, replaceIdentityRefreshToken, arg.NewTokenID, arg.OldTokenID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const revokeAllIdentityRefreshToken = `-- name: RevokeAllIdentityRefreshToken :exec
UPDATE identity_refresh_tokens 
SET 
    revoked = TRUE
WHERE 
    user_id = $1
`

func (q *Queries) RevokeAllIdentityRefreshToken(ctx context.Context, userID int64) error {
	_, err := q.db.Exec(ctx, revokeAllIdentityRefreshToken, userID)
	return err
}

const revokeIdentityRefreshToken = `-- name: RevokeIdentityRefreshToken :exec
UPDATE identity_refresh_tokens 
SET 
    revoked = TRUE
WHERE 
    token = $1
`

func (q *Queries) RevokeIdentityRefreshToken(ctx context.Context, token string) error {
	_, err := q.db.Exec(ctx, revokeIdentityRefreshToken, token)
	return err
}

const updateIdentityMFALastUsedAt = `-- name: UpdateIdentityMFALastUsedAt :exec
UPDATE identity_mfa_factors
SET 
    last_used_at = NOW()
WHERE
    id = $1 AND
    user_id = $2
`

type UpdateIdentityMFALastUsedAtParams struct {
	ID     int64
	UserID int64
}

func (q *Queries) UpdateIdentityMFALastUsedAt(ctx context.Context, arg UpdateIdentityMFALastUsedAtParams) error {
	_, err := q.db.Exec(ctx, updateIdentityMFALastUsedAt, arg.ID, arg.UserID)
	return err
}

const updateIdentityUserAvatar = `-- name: UpdateIdentityUserAvatar :exec
UPDATE identity_users
SET 
    avatar_url = $1,
    updated_by = $2
WHERE
    id = $3 AND
    deleted_at IS NULL
`

type UpdateIdentityUserAvatarParams struct {
	AvatarUrl string
	UpdatedBy int64
	ID        int64
}

func (q *Queries) UpdateIdentityUserAvatar(ctx context.Context, arg UpdateIdentityUserAvatarParams) error {
	_, err := q.db.Exec(ctx, updateIdentityUserAvatar, arg.AvatarUrl, arg.UpdatedBy, arg.ID)
	return err
}

const updateIdentityUserCredential = `-- name: UpdateIdentityUserCredential :exec
UPDATE identity_user_credentials 
SET 
    password = $1
WHERE 
    user_id = $2
`

type UpdateIdentityUserCredentialParams struct {
	Password string
	UserID   int64
}

func (q *Queries) UpdateIdentityUserCredential(ctx context.Context, arg UpdateIdentityUserCredentialParams) error {
	_, err := q.db.Exec(ctx, updateIdentityUserCredential, arg.Password, arg.UserID)
	return err
}

const updateIdentityUserName = `-- name: UpdateIdentityUserName :exec
UPDATE identity_users
SET 
    full_name = $1,
    updated_by = $2
WHERE
    id = $3 AND
    deleted_at IS NULL
`

type UpdateIdentityUserNameParams struct {
	FullName  string
	UpdatedBy int64
	ID        int64
}

func (q *Queries) UpdateIdentityUserName(ctx context.Context, arg UpdateIdentityUserNameParams) error {
	_, err := q.db.Exec(ctx, updateIdentityUserName, arg.FullName, arg.UpdatedBy, arg.ID)
	return err
}

const updateIdentityUserStatus = `-- name: UpdateIdentityUserStatus :exec
UPDATE identity_users
SET 
    status = $1,
    updated_by = $2
WHERE 
    id = $3 
    AND status = $4
    AND deleted_at IS NULL
`

type UpdateIdentityUserStatusParams struct {
	NewStatus identity_entity.UserStatus
	UpdatedBy int64
	ID        int64
	OldStatus identity_entity.UserStatus
}

func (q *Queries) UpdateIdentityUserStatus(ctx context.Context, arg UpdateIdentityUserStatusParams) error {
	_, err := q.db.Exec(ctx, updateIdentityUserStatus,
		arg.NewStatus,
		arg.UpdatedBy,
		arg.ID,
		arg.OldStatus,
	)
	return err
}

const verifyIdentityMFAFactor = `-- name: VerifyIdentityMFAFactor :exec

UPDATE identity_mfa_factors
SET 
    is_verified = TRUE
WHERE
    id = $1 AND
    user_id = $2
`

type VerifyIdentityMFAFactorParams struct {
	ID     int64
	UserID int64
}

// ***** ***** *****
// UPDATE DATA
// ***** ***** *****
func (q *Queries) VerifyIdentityMFAFactor(ctx context.Context, arg VerifyIdentityMFAFactorParams) error {
	_, err := q.db.Exec(ctx, verifyIdentityMFAFactor, arg.ID, arg.UserID)
	return err
}
