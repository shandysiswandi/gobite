// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query_notification.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	notif_entity "github.com/shandysiswandi/gobite/internal/notification/entity"
	vo "github.com/shandysiswandi/gobite/internal/pkg/valueobject"
)

const countNotificationsUnread = `-- name: CountNotificationsUnread :one
SELECT COUNT(*)::BIGINT
FROM notifications
WHERE 
    user_id = $1 AND 
    read_at IS NULL AND 
    deleted_at IS NULL
`

func (q *Queries) CountNotificationsUnread(ctx context.Context, userID int64) (int64, error) {
	row := q.db.QueryRow(ctx, countNotificationsUnread, userID)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const createNotification = `-- name: CreateNotification :exec
INSERT INTO notifications (id, user_id, category_id, trigger_key, data, metadata) 
VALUES ($1, $2, $3, $4, $5, $6)
`

type CreateNotificationParams struct {
	ID         int64
	UserID     int64
	CategoryID int64
	TriggerKey string
	Data       vo.JSONMap
	Metadata   vo.JSONMap
}

func (q *Queries) CreateNotification(ctx context.Context, arg CreateNotificationParams) error {
	_, err := q.db.Exec(ctx, createNotification,
		arg.ID,
		arg.UserID,
		arg.CategoryID,
		arg.TriggerKey,
		arg.Data,
		arg.Metadata,
	)
	return err
}

const createNotificationDeliveryLog = `-- name: CreateNotificationDeliveryLog :one
INSERT INTO notification_delivery_logs (notification_id, channel, status)
VALUES ($1, $2, $3) RETURNING id
`

type CreateNotificationDeliveryLogParams struct {
	NotificationID int64
	Channel        notif_entity.Channel
	Status         notif_entity.DeliveryStatus
}

func (q *Queries) CreateNotificationDeliveryLog(ctx context.Context, arg CreateNotificationDeliveryLogParams) (int64, error) {
	row := q.db.QueryRow(ctx, createNotificationDeliveryLog, arg.NotificationID, arg.Channel, arg.Status)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getNotificationTemplateByTriggerChannel = `-- name: GetNotificationTemplateByTriggerChannel :one

SELECT id, trigger_key, category_id, channel, subject, body
FROM notification_templates
WHERE 
    trigger_key = $1 AND 
    channel = $2
`

type GetNotificationTemplateByTriggerChannelParams struct {
	TriggerKey string
	Channel    notif_entity.Channel
}

type GetNotificationTemplateByTriggerChannelRow struct {
	ID         int64
	TriggerKey string
	CategoryID int64
	Channel    notif_entity.Channel
	Subject    string
	Body       string
}

// ***** ***** *****
// SELECT DATA
// ***** ***** *****
func (q *Queries) GetNotificationTemplateByTriggerChannel(ctx context.Context, arg GetNotificationTemplateByTriggerChannelParams) (GetNotificationTemplateByTriggerChannelRow, error) {
	row := q.db.QueryRow(ctx, getNotificationTemplateByTriggerChannel, arg.TriggerKey, arg.Channel)
	var i GetNotificationTemplateByTriggerChannelRow
	err := row.Scan(
		&i.ID,
		&i.TriggerKey,
		&i.CategoryID,
		&i.Channel,
		&i.Subject,
		&i.Body,
	)
	return i, err
}

const listNotificationCategories = `-- name: ListNotificationCategories :many
SELECT id, name, description, is_mandatory
FROM notification_categories
ORDER BY id ASC
`

type ListNotificationCategoriesRow struct {
	ID          int64
	Name        string
	Description string
	IsMandatory bool
}

func (q *Queries) ListNotificationCategories(ctx context.Context) ([]ListNotificationCategoriesRow, error) {
	rows, err := q.db.Query(ctx, listNotificationCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListNotificationCategoriesRow
	for rows.Next() {
		var i ListNotificationCategoriesRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.IsMandatory,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNotificationUserSettings = `-- name: ListNotificationUserSettings :many
SELECT user_id, category_id, channel, is_enabled
FROM notification_user_settings
WHERE 
    user_id = $1
`

type ListNotificationUserSettingsRow struct {
	UserID     int64
	CategoryID int64
	Channel    notif_entity.Channel
	IsEnabled  bool
}

func (q *Queries) ListNotificationUserSettings(ctx context.Context, userID int64) ([]ListNotificationUserSettingsRow, error) {
	rows, err := q.db.Query(ctx, listNotificationUserSettings, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListNotificationUserSettingsRow
	for rows.Next() {
		var i ListNotificationUserSettingsRow
		if err := rows.Scan(
			&i.UserID,
			&i.CategoryID,
			&i.Channel,
			&i.IsEnabled,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNotificationsByUserAll = `-- name: ListNotificationsByUserAll :many
SELECT id, user_id, category_id, trigger_key, data, metadata, read_at, created_at
FROM notifications
WHERE 
    user_id = $1 AND 
    deleted_at IS NULL
ORDER BY 
    created_at DESC, 
    id DESC
LIMIT $3 OFFSET $2
`

type ListNotificationsByUserAllParams struct {
	UserID     int64
	PageOffset int32
	PageLimit  int32
}

type ListNotificationsByUserAllRow struct {
	ID         int64
	UserID     int64
	CategoryID int64
	TriggerKey string
	Data       vo.JSONMap
	Metadata   vo.JSONMap
	ReadAt     pgtype.Timestamptz
	CreatedAt  pgtype.Timestamptz
}

func (q *Queries) ListNotificationsByUserAll(ctx context.Context, arg ListNotificationsByUserAllParams) ([]ListNotificationsByUserAllRow, error) {
	rows, err := q.db.Query(ctx, listNotificationsByUserAll, arg.UserID, arg.PageOffset, arg.PageLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListNotificationsByUserAllRow
	for rows.Next() {
		var i ListNotificationsByUserAllRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.CategoryID,
			&i.TriggerKey,
			&i.Data,
			&i.Metadata,
			&i.ReadAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNotificationsByUserRead = `-- name: ListNotificationsByUserRead :many
SELECT id, user_id, category_id, trigger_key, data, metadata, read_at, created_at
FROM notifications
WHERE 
    user_id = $1 AND 
    read_at IS NOT NULL AND 
    deleted_at IS NULL
ORDER BY 
    created_at DESC, 
    id DESC
LIMIT $3 OFFSET $2
`

type ListNotificationsByUserReadParams struct {
	UserID     int64
	PageOffset int32
	PageLimit  int32
}

type ListNotificationsByUserReadRow struct {
	ID         int64
	UserID     int64
	CategoryID int64
	TriggerKey string
	Data       vo.JSONMap
	Metadata   vo.JSONMap
	ReadAt     pgtype.Timestamptz
	CreatedAt  pgtype.Timestamptz
}

func (q *Queries) ListNotificationsByUserRead(ctx context.Context, arg ListNotificationsByUserReadParams) ([]ListNotificationsByUserReadRow, error) {
	rows, err := q.db.Query(ctx, listNotificationsByUserRead, arg.UserID, arg.PageOffset, arg.PageLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListNotificationsByUserReadRow
	for rows.Next() {
		var i ListNotificationsByUserReadRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.CategoryID,
			&i.TriggerKey,
			&i.Data,
			&i.Metadata,
			&i.ReadAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNotificationsByUserUnread = `-- name: ListNotificationsByUserUnread :many
SELECT id, user_id, category_id, trigger_key, data, metadata, read_at, created_at
FROM notifications
WHERE 
    user_id = $1 AND 
    read_at IS NULL AND 
    deleted_at IS NULL
ORDER BY 
    created_at DESC, 
    id DESC
LIMIT $3 OFFSET $2
`

type ListNotificationsByUserUnreadParams struct {
	UserID     int64
	PageOffset int32
	PageLimit  int32
}

type ListNotificationsByUserUnreadRow struct {
	ID         int64
	UserID     int64
	CategoryID int64
	TriggerKey string
	Data       vo.JSONMap
	Metadata   vo.JSONMap
	ReadAt     pgtype.Timestamptz
	CreatedAt  pgtype.Timestamptz
}

func (q *Queries) ListNotificationsByUserUnread(ctx context.Context, arg ListNotificationsByUserUnreadParams) ([]ListNotificationsByUserUnreadRow, error) {
	rows, err := q.db.Query(ctx, listNotificationsByUserUnread, arg.UserID, arg.PageOffset, arg.PageLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListNotificationsByUserUnreadRow
	for rows.Next() {
		var i ListNotificationsByUserUnreadRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.CategoryID,
			&i.TriggerKey,
			&i.Data,
			&i.Metadata,
			&i.ReadAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markNotificationRead = `-- name: MarkNotificationRead :execrows
UPDATE notifications
SET read_at = NOW()
WHERE 
    id = $1 AND 
    user_id = $2 AND 
    read_at IS NULL AND 
    deleted_at IS NULL
`

type MarkNotificationReadParams struct {
	ID     int64
	UserID int64
}

func (q *Queries) MarkNotificationRead(ctx context.Context, arg MarkNotificationReadParams) (int64, error) {
	result, err := q.db.Exec(ctx, markNotificationRead, arg.ID, arg.UserID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const markNotificationsReadAll = `-- name: MarkNotificationsReadAll :execrows
UPDATE notifications
SET read_at = NOW()
WHERE 
    user_id = $1 AND 
    read_at IS NULL AND 
    deleted_at IS NULL
`

func (q *Queries) MarkNotificationsReadAll(ctx context.Context, userID int64) (int64, error) {
	result, err := q.db.Exec(ctx, markNotificationsReadAll, userID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const registerNotificationUserDevice = `-- name: RegisterNotificationUserDevice :exec

INSERT INTO notification_user_devices (user_id, device_token, platform, last_active_at)
VALUES ($1, $2, $3, NOW())
ON CONFLICT (device_token) 
DO UPDATE SET 
    user_id = EXCLUDED.user_id,
    platform = EXCLUDED.platform,
    last_active_at = NOW()
`

type RegisterNotificationUserDeviceParams struct {
	UserID      int64
	DeviceToken string
	Platform    string
}

// ***** ***** *****
// CREATE DATA
// ***** ***** *****
func (q *Queries) RegisterNotificationUserDevice(ctx context.Context, arg RegisterNotificationUserDeviceParams) error {
	_, err := q.db.Exec(ctx, registerNotificationUserDevice, arg.UserID, arg.DeviceToken, arg.Platform)
	return err
}

const removeNotificationUserDevice = `-- name: RemoveNotificationUserDevice :exec

DELETE FROM notification_user_devices 
WHERE 
    device_token = $1
`

// ***** ***** *****
// DELETE DATA
// ***** ***** *****
func (q *Queries) RemoveNotificationUserDevice(ctx context.Context, deviceToken string) error {
	_, err := q.db.Exec(ctx, removeNotificationUserDevice, deviceToken)
	return err
}

const softDeleteNotification = `-- name: SoftDeleteNotification :execrows
UPDATE notifications
SET deleted_at = NOW()
WHERE 
    id = $1 AND 
    user_id = $2 AND 
    deleted_at IS NULL
`

type SoftDeleteNotificationParams struct {
	ID     int64
	UserID int64
}

func (q *Queries) SoftDeleteNotification(ctx context.Context, arg SoftDeleteNotificationParams) (int64, error) {
	result, err := q.db.Exec(ctx, softDeleteNotification, arg.ID, arg.UserID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const updateNotificationDeliveryLogStatus = `-- name: UpdateNotificationDeliveryLogStatus :exec
UPDATE notification_delivery_logs
SET
    status = $1,
    provider_response = $2,
    updated_at = NOW(),
    attempt_count = attempt_count + 1,
    next_retry_at = $3
WHERE id = $4
`

type UpdateNotificationDeliveryLogStatusParams struct {
	Status           notif_entity.DeliveryStatus
	ProviderResponse vo.JSONMap
	NextRetryAt      pgtype.Timestamptz
	ID               int64
}

func (q *Queries) UpdateNotificationDeliveryLogStatus(ctx context.Context, arg UpdateNotificationDeliveryLogStatusParams) error {
	_, err := q.db.Exec(ctx, updateNotificationDeliveryLogStatus,
		arg.Status,
		arg.ProviderResponse,
		arg.NextRetryAt,
		arg.ID,
	)
	return err
}

const upsertNotificationUserSetting = `-- name: UpsertNotificationUserSetting :exec
INSERT INTO notification_user_settings (user_id, category_id, channel, is_enabled)
VALUES ($1, $2, $3, $4)
ON CONFLICT (user_id, category_id, channel)
DO UPDATE SET
    is_enabled = EXCLUDED.is_enabled,
    updated_at = NOW()
`

type UpsertNotificationUserSettingParams struct {
	UserID     int64
	CategoryID int64
	Channel    notif_entity.Channel
	IsEnabled  bool
}

func (q *Queries) UpsertNotificationUserSetting(ctx context.Context, arg UpsertNotificationUserSettingParams) error {
	_, err := q.db.Exec(ctx, upsertNotificationUserSetting,
		arg.UserID,
		arg.CategoryID,
		arg.Channel,
		arg.IsEnabled,
	)
	return err
}
